Задание 18
Отлично!
Запускаем и наслаждаемся змейкой.


Задание 17
Теперь закончим класс Shake
Надо:
а) реализовать метод checkBorders: если голова змеи за границами комнаты - змея умирает (isAlive = false)
б)  реализовать метод checkBody: если голова змеи пересекается с ее телом (любым из кусочков) - змея умирает (isAlive = false)

Реализовать метод  move(int dx, int dy):
в) создать голову(кусочек змеи) с правильными координатами
г) проверить, не вылезла ли она за границу комнаты (если да, то змея умирает)
д) проверить, не совпадает ли она с уже существующими кусочками змеи (если да, то змея умирает)
е) добавить голову к змее (со стороны головы) и удалить последний кусочек из хвоста.
ж) если змея поймала мышь (координаты головы совпадают с координатами мыши), то удалять кусок из хвоста не надо.


Задание 16
Продолжаем работать над методом move()
Для определения не пересекается ли змея сама с собой можно сделать очень простую проверку:
содержит ли список sections "новую голову змеи".
Код для этого будет выглядеть примерно так:
if (sections.contains(head))
При этом head должен быть еще не добавлен в список sections, иначе будет всегда true.
Но чтобы этот код работал, надо реализовать методы сравнения объектов (equals & hashCode) в классе SnakeSection.

Задание: реализовать методы  equals & hashCode в классе SnakeSection.

Сигнатура методов:
public boolean equals(Object o)
public int hashCode()

Подсказка:
Используй Alt+Insert в Intellij IDEA


Задание 15
Теперь осталось допилить змею.
Вот что я предлагаю насчет движения змеи:
Змея состоит из кусочков. Давай каждый ход просто добавлять один кусочек со стороны головы,
а самый последний - удалять. Тогда получится что змея ползет.

Добавлять кусочек нужно рядом с текущей головой (кусочком номер 0).
С какой стороны добавлять зависит от direction (UP, DOWN, LEFT, RIGHT).
Подсказка:
а) Как добавить кусочек змеи в начало списка sections?
sections.add(0, new_section);
б) А как удалить последний?
sections.remove(sections.size()-1);

В методе move надо:
а) сделать шаг в ткущем направлении (определяется direction)
б) проверить, что если змея уперлась в стену, то умереть (isAlive = false)
в) проверить, что если змея уперлась себя, то умереть (isAlive = false)
г) проверить, если змея встретила мышь - то съесть ее.



Задание 14
Теперь поработаем над методом print().
Надо:
а) вывести на экран прямоугольник из точек размером width x height.
б) тело змеи отметить символом "x"-английское
в) голову змеи нарисовать символом X-английское.
Подсказка:
а) удобно сначала создать матрицу типа int[][] с размером (height x width)
б) затем пройтись по все объектам и отрисовать их в матрицу.
Например тело змеи - 1, голова змеи - 2, мышь - 3.



Задание 13
Предлагаю тебе в этот раз написать специальный метод sleep().
Который будет делать паузу в зависимости от длинны змеи (количества элементов в sections).
Придумай какой-нибудь хитрый алгоритм. Чтобы на первом уровне пауза была 500 миллисекунд,
а к 10 уровню постепенно уменьшилась до 300.
И ниже 200 не опускалась.



Задание 12
Добавить в метод main:
в) вызов метода createMouse().
Змея-то у нас есть, пусть и мышь будет
г) вызов метода run().
Без него ничего работать не будет. В нем вся основная логика.
Неплохо получилось, но я все-таки внесу пару правок.
Кстати, как насчет написать метод sleep?
Ты уже понял из предыдущих задач, что в методе run нужна пауза.
Но насколько я помню, скорость в змейке должна рости при росте ее длинны.
Значит чем длиннее змея, тем выше скорость и меньше пауза.


Задание 11
Теперь логика управления мышью.
С мышью у нас будут происходить две вещи.
Первая - змея съест мышь.
Вторая - появляется новая мышь в случайной точке комнаты.

Надо написать и реализовать метод createMouse() в классе Room.
В это методы мы просто должны создавать новую мышь со случайными координатами в комнате.
Как получить случайные координаты?
Это ты уже должен был знать. На всякий случай даю подсказку:
int x = (int) (Math.random() * width);

Еще понадобится метод - eatMouse(), на случай, если мышь все-таки кто-то съест :)
Пока сложной логики в это методе не будет - просто будем вызвать метод createMouse и все.



Задание 10
Займемся методом main.
Для начала надо создать статическую переменную game типа Room.
Затем в методе main:
а) Создать змею - объект Snake
б) Создать комнату - объект типа Room и передать в него ширину, высоту и змею.
в) Установить змее direction равным SnakeDirection.DOWN
Чего еще не хватает? Собственно метода в котором будет идти вся игровая логика.
И еще нужен метод, который бы отрисовывал все это на экране.
а) создать метод run()
б) создать метод print()



Задание 9
Еще остался самый главный класс - Room.
Что нам нужно для его описания?
Размеры комнаты (width и height) - раз.
Змея - два
Мышь - три.

Надо:
а) создать в классе Room переменные width & height типа int.
б) создать в классе Room переменную snake типа Snake.
в) создать в классе Room переменную mouse типа Snake. Шучу. Типа Mouse, конечно же :)
г) создать для них всех геттеры и сеттеры.
д) создать конструктор. Конструктор должен принимать три параметра: width, height и ... snake!



Задание 8
Настала очередь конструктора класса Snake.
Змея у нас будет поначалу состоять из одного кусочка - головы.
А что для него требуется?
Что необходимо передать в конструктор?
Координаты змеи, конечно же.

Надо:
а) Передать в конструктор координаты головы змеи (x и y)
б) создать в нем первый "кусочек змеи" (голову) и добавить его в коллекцию sections.
в) isAlive выставить в true
г) не забудь в конструкторе инициализировать переменную sections. В null не много-то и добавишь!
д) еще добавить классу метод move()- он нам пригодится попозже.



Задание 7
"Кусочки змеи" мы описали, теперь займемся самой змеей.
У змеи должен быть список кусочков(SnakeSection) и голова.
Пусть головой будет просто самый первый кусочек (с номером 0).

У змеи также есть направление движения - сторона куда она движется по умолчанию.
А еще есть состояние - жива змея или мертва.
Игра заканчивается тогда, когда змея мертва.
Надо:
а) Добавить в класс Snake переменную sections типа ArrayList<SnakeSection>.
б) Добавить переменную isAlive логического типа.
в) Добавить переменную direction типа SnakeSection.
г) Для всех них добавить getter'ы, а для direction еще и setter.
Примечание:
Для булевских переменных геттер принято писать не как getValue(), а как isValue() - это улучшает читабельность кода.



Задание 6
Теперь займемся классом SnakeSection.
Он будет описывать один кусочек змеи.

А у каждого кусочка что есть?
Правильно! Координаты.
Добавь две переменных к классу SnakeSection: x и y типа int.
Добавь для них getter'ы и конструктор с двумя параметрами.



Задание 5
Теперь доделаем SnakeDirection.
а) Переделай его в enum: замени ключевое слово class на enum
б) Добавь 4 значения UP, DOWN, LEFT, RIGHT
Должно получиться примерно так:
public enum  SnakeDirection
{
    UP,
    RIGHT,
    DOWN,
    LEFT
}



Задание 4
Отлично. Я еще добавил KeyboardObserver на будущее.
Пригодится.

Насчнем с самого простого - класса Mouse.
Мышь не будет двигаться и у нее будут только координаты и все.
Добавь две переменных к классу Mouse: x и y типа int.
Добавь для них getter'ы и конструктор с двумя параметрами.



Задание 3
Теперь самое интересное - как будет устроена змея.
Что можно сказать о змее:
а) По сути - змея это набор кусочков - клеточек. Но точно известно, что один из них - голова.
б) У змеи есть направление движения.

Так что нам еще понадобятся классы:
SnakeSection - кусочек змеи.
SnakeDirection - класс (enum) будет описывать направление движения змеи.

Создай классы SnakeSection и SnakeDirection



Задание 2
А добавь-ка еще метод main в класс Room.



Задание 1
А теперь напишем игру "змейка".
Для этого нам понадобятся:
а) собственно сама змея (класс Snake)
б) комната в которой она будет ползать (класс Room)
в) мыши, которых она будет есть (класс Mouse)

Создай классы Snake, Room, Mouse


